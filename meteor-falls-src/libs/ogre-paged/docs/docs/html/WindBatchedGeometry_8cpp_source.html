<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>PagedGeometry: /home/thomas/meteor-falls/meteor-falls-src/libs/ogre-paged/source/WindBatchedGeometry.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">PagedGeometry
   &#160;<span id="projectnumber">1.1.4</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/thomas/meteor-falls/meteor-falls-src/libs/ogre-paged/source/WindBatchedGeometry.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*-------------------------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2006 John Judnich</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00005"></a>00005 <span class="comment">Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:</span>
<a name="l00006"></a>00006 <span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00007"></a>00007 <span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00008"></a>00008 <span class="comment">3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00009"></a>00009 <span class="comment">-------------------------------------------------------------------------------------*/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">//WindBatchedGeometry.h</span>
<a name="l00012"></a>00012 <span class="comment">//A &quot;lightweight&quot; version of Ogre::StaticGeometry, which gives you a little more control</span>
<a name="l00013"></a>00013 <span class="comment">//over the batch materials, etc.</span>
<a name="l00014"></a>00014 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;OgreRoot.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;OgreRenderSystem.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;OgreCamera.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;OgreVector3.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;OgreQuaternion.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;OgreSceneNode.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;OgreString.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;OgreStringConverter.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;OgreEntity.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;OgreSubMesh.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;OgreSubEntity.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;OgreMesh.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;OgreMeshManager.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;OgreHardwareBufferManager.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;OgreHardwareBuffer.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;OgreMaterialManager.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;OgreMaterial.h&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;WindBatchedGeometry.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;PagedGeometry.h&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">using namespace </span>Ogre;
<a name="l00038"></a>00038 <span class="keyword">using namespace </span>Forests;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00043"></a>00043 <span class="comment"></span>WindBatchedGeometry::WindBatchedGeometry(SceneManager *mgr, SceneNode *rootSceneNode, <span class="keyword">const</span> PagedGeometry *pagedGeom) : 
<a name="l00044"></a>00044 <a class="code" href="classForests_1_1BatchedGeometry.html" title="A &quot;lightweight&quot; version of Ogre::StaticGeometry, which gives you a little more control over the batch...">BatchedGeometry</a>(mgr, rootSceneNode),
<a name="l00045"></a>00045 mGeom (pagedGeom)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047    <span class="comment">// empty</span>
<a name="l00048"></a>00048 }
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00053"></a>00053 <span class="comment"></span><span class="keywordtype">void</span> WindBatchedGeometry::addEntity(Entity *ent, <span class="keyword">const</span> Vector3 &amp;position, <span class="keyword">const</span> Quaternion &amp;orientation, <span class="keyword">const</span> Vector3 &amp;scale, <span class="keyword">const</span> ColourValue &amp;color)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055     MeshPtr mesh = ent-&gt;getMesh();
<a name="l00056"></a>00056     <span class="keywordflow">if</span> (mesh-&gt;sharedVertexData != NULL)
<a name="l00057"></a>00057         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, <span class="stringliteral">&quot;Shared vertex data not allowed&quot;</span>, <span class="stringliteral">&quot;BatchedGeometry::addEntity()&quot;</span>);
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     <span class="comment">//For each subentity</span>
<a name="l00060"></a>00060     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, cntSubEnt = ent-&gt;getNumSubEntities(); i &lt; cntSubEnt; ++i)
<a name="l00061"></a>00061    {
<a name="l00062"></a>00062         <span class="comment">//Get the subentity</span>
<a name="l00063"></a>00063         SubEntity *subEntity = ent-&gt;getSubEntity(i);
<a name="l00064"></a>00064         SubMesh *subMesh = subEntity-&gt;getSubMesh();
<a name="l00065"></a>00065 
<a name="l00066"></a>00066         <span class="comment">//Generate a format string that uniquely identifies this material &amp; vertex/index format</span>
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (subMesh-&gt;vertexData == NULL)
<a name="l00068"></a>00068             OGRE_EXCEPT(Exception::ERR_INTERNAL_ERROR, <span class="stringliteral">&quot;SubMesh vertex data not found!&quot;</span>, <span class="stringliteral">&quot;BatchedGeometry::addEntity()&quot;</span>);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070         String formatStr = getFormatString(subEntity);
<a name="l00071"></a>00071         
<a name="l00072"></a>00072         <span class="comment">//If a batch using an identical format exists...</span>
<a name="l00073"></a>00073         WindSubBatch *batch;
<a name="l00074"></a>00074         TSubBatchMap::iterator batchIter = m_mapSubBatch.find(formatStr);
<a name="l00075"></a>00075         <span class="keywordflow">if</span> (batchIter != m_mapSubBatch.end())
<a name="l00076"></a>00076             batch = static_cast &lt; WindBatchedGeometry::WindSubBatch* &gt; (batchIter-&gt;second);  <span class="comment">//Use the batch</span>
<a name="l00077"></a>00077       <span class="keywordflow">else</span>
<a name="l00078"></a>00078       {  <span class="comment">//Otherwise create a new batch</span>
<a name="l00079"></a>00079             batch = <span class="keyword">new</span> WindSubBatch(<span class="keyword">this</span>, subEntity);
<a name="l00080"></a>00080             m_mapSubBatch.insert(std::pair&lt;String, SubBatch*&gt;(formatStr, batch));
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="comment">//Now add the submesh to the compatible batch</span>
<a name="l00084"></a>00084         batch-&gt;addSubEntity(subEntity, position, orientation, scale, color, ent);
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">//Update bounding box</span>
<a name="l00088"></a>00088     Matrix4 mat(orientation);
<a name="l00089"></a>00089     mat.setScale(scale);
<a name="l00090"></a>00090     AxisAlignedBox entBounds = ent-&gt;getBoundingBox();
<a name="l00091"></a>00091     entBounds.transform(mat);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <span class="keywordflow">if</span> (m_BoundsUndefined)
<a name="l00094"></a>00094    {
<a name="l00095"></a>00095         m_boundsAAB.setMinimum(entBounds.getMinimum() + position);
<a name="l00096"></a>00096         m_boundsAAB.setMaximum(entBounds.getMaximum() + position);
<a name="l00097"></a>00097         m_BoundsUndefined = <span class="keyword">false</span>;
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099    <span class="keywordflow">else</span>
<a name="l00100"></a>00100    {
<a name="l00101"></a>00101         Vector3 min = m_boundsAAB.getMinimum();
<a name="l00102"></a>00102         Vector3 max = m_boundsAAB.getMaximum();
<a name="l00103"></a>00103         min.makeFloor(entBounds.getMinimum() + position);
<a name="l00104"></a>00104         max.makeCeil(entBounds.getMaximum() + position);
<a name="l00105"></a>00105         m_boundsAAB.setMinimum(min);
<a name="l00106"></a>00106         m_boundsAAB.setMaximum(max);
<a name="l00107"></a>00107     }
<a name="l00108"></a>00108     
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00114"></a><a class="code" href="classForests_1_1WindBatchedGeometry_1_1WindSubBatch.html#a0d66b6d04216ef69a21cc35ed0307942">00114</a> <span class="comment"></span><a class="code" href="classForests_1_1WindBatchedGeometry_1_1WindSubBatch.html#a0d66b6d04216ef69a21cc35ed0307942" title="Constructor.">WindBatchedGeometry::WindSubBatch::WindSubBatch</a>(<a class="code" href="classForests_1_1WindBatchedGeometry.html" title="A variation of BatchedGeometry designed for WindBatchPage.">WindBatchedGeometry</a> *parent, SubEntity *ent) : 
<a name="l00115"></a>00115 <a class="code" href="classForests_1_1BatchedGeometry.html" title="A &quot;lightweight&quot; version of Ogre::StaticGeometry, which gives you a little more control over the batch...">BatchedGeometry</a>::<a class="code" href="classForests_1_1BatchedGeometry_1_1SubBatch.html" title="Visible chunk of geometry.">SubBatch</a>(parent, ent)
<a name="l00116"></a>00116 {
<a name="l00117"></a>00117    <span class="comment">// empty</span>
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00123"></a><a class="code" href="classForests_1_1WindBatchedGeometry_1_1WindSubBatch.html#ac63bfc4719611f2c56113d8ee73a327a">00123</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classForests_1_1BatchedGeometry.html#af899bc7c6a41ae5354855d915d53c1de">WindBatchedGeometry::WindSubBatch::build</a>()
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125     assert(!m_Built);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     <span class="comment">//Misc. setup</span>
<a name="l00128"></a>00128     <span class="keyword">const</span> Vector3 &amp;batchCenter = static_cast &lt; <a class="code" href="classForests_1_1WindBatchedGeometry.html" title="A variation of BatchedGeometry designed for WindBatchPage.">WindBatchedGeometry</a>* &gt; (m_pParentGeom)-&gt;m_vecCenter;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     HardwareIndexBuffer::IndexType srcIndexType = m_pSubMesh-&gt;indexData-&gt;indexBuffer-&gt;getType();
<a name="l00131"></a>00131     HardwareIndexBuffer::IndexType destIndexType = 
<a name="l00132"></a>00132       m_pVertexData-&gt;vertexCount &gt; 0xFFFF || srcIndexType == HardwareIndexBuffer::IT_32BIT ?
<a name="l00133"></a>00133       HardwareIndexBuffer::IT_32BIT : HardwareIndexBuffer::IT_16BIT;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="comment">//Allocate the index buffer</span>
<a name="l00136"></a>00136     m_pIndexData-&gt;indexBuffer = HardwareBufferManager::getSingleton().createIndexBuffer(
<a name="l00137"></a>00137       destIndexType, m_pIndexData-&gt;indexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="comment">//Lock the index buffer</span>
<a name="l00140"></a>00140     uint32 *indexBuffer32 = 0;
<a name="l00141"></a>00141     uint16 *indexBuffer16 = 0;
<a name="l00142"></a>00142     <span class="keywordflow">if</span> (destIndexType == HardwareIndexBuffer::IT_32BIT)
<a name="l00143"></a>00143         indexBuffer32 = <span class="keyword">static_cast&lt;</span>uint32*<span class="keyword">&gt;</span>(m_pIndexData-&gt;indexBuffer-&gt;lock(HardwareBuffer::HBL_DISCARD));
<a name="l00144"></a>00144     <span class="keywordflow">else</span>
<a name="l00145"></a>00145         indexBuffer16 = <span class="keyword">static_cast&lt;</span>uint16*<span class="keyword">&gt;</span>(m_pIndexData-&gt;indexBuffer-&gt;lock(HardwareBuffer::HBL_DISCARD));
<a name="l00146"></a>00146 
<a name="l00147"></a>00147    VertexBufferBinding *vertBinding = m_pVertexData-&gt;vertexBufferBinding;
<a name="l00148"></a>00148     VertexDeclaration *vertDecl = m_pVertexData-&gt;vertexDeclaration;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> texCoordCount = 0;
<a name="l00151"></a>00151    {
<a name="l00152"></a>00152       <span class="keyword">const</span> VertexDeclaration::VertexElementList &amp;vlist = vertDecl-&gt;getElements();
<a name="l00153"></a>00153       VertexDeclaration::VertexElementList::const_iterator it = vlist.begin(), iend = vlist.end();
<a name="l00154"></a>00154       <span class="keywordflow">while</span> (it != iend)
<a name="l00155"></a>00155       {
<a name="l00156"></a>00156          <span class="keywordflow">if</span> ((*it).getSemantic() == VES_TEXTURE_COORDINATES)
<a name="l00157"></a>00157             ++texCoordCount;
<a name="l00158"></a>00158          ++it;
<a name="l00159"></a>00159       }
<a name="l00160"></a>00160    }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162    Ogre::ushort numVertBuffs = (Ogre::ushort)vertBinding-&gt;getBufferCount();
<a name="l00163"></a>00163 
<a name="l00164"></a>00164    vertDecl-&gt;addElement(numVertBuffs - 1, vertDecl-&gt;getVertexSize(0), VET_FLOAT4 , VES_TEXTURE_COORDINATES, texCoordCount);
<a name="l00165"></a>00165    vertDecl-&gt;addElement(numVertBuffs - 1, vertDecl-&gt;getVertexSize(0), VET_FLOAT4 , VES_TEXTURE_COORDINATES, texCoordCount+1);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167    <span class="comment">//Allocate &amp; lock the vertex buffers</span>
<a name="l00168"></a>00168    std::vector&lt;uchar*&gt; vertexBuffers(numVertBuffs);
<a name="l00169"></a>00169    std::vector&lt;VertexDeclaration::VertexElementList&gt; vertexBufferElements(numVertBuffs);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keywordflow">for</span> (Ogre::ushort i = 0; i &lt; numVertBuffs; ++i)
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173         HardwareVertexBufferSharedPtr buffer = HardwareBufferManager::getSingleton().createVertexBuffer(
<a name="l00174"></a>00174          vertDecl-&gt;getVertexSize(i), m_pVertexData-&gt;vertexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         vertBinding-&gt;setBinding(i, buffer);
<a name="l00177"></a>00177         
<a name="l00178"></a>00178         vertexBuffers[i] = <span class="keyword">static_cast&lt;</span>uchar*<span class="keyword">&gt;</span>(buffer-&gt;lock(HardwareBuffer::HBL_DISCARD));
<a name="l00179"></a>00179         vertexBufferElements[i] = vertDecl-&gt;findElementsBySource(i);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     <span class="comment">//If no vertex colors are used, make sure the final batch includes them (so the shade values work)</span>
<a name="l00183"></a>00183    <span class="keywordflow">if</span> (m_RequireVertexColors)
<a name="l00184"></a>00184    {
<a name="l00185"></a>00185       <span class="keywordflow">if</span> (!m_pVertexData-&gt;vertexDeclaration-&gt;findElementBySemantic(VES_DIFFUSE))
<a name="l00186"></a>00186       {
<a name="l00187"></a>00187          Ogre::ushort i = (Ogre::ushort)vertBinding-&gt;getBufferCount();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189          vertDecl-&gt;addElement(i, 0, VET_COLOUR, VES_DIFFUSE);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191          HardwareVertexBufferSharedPtr buffer = HardwareBufferManager::getSingleton().createVertexBuffer(
<a name="l00192"></a>00192             vertDecl-&gt;getVertexSize(i), m_pVertexData-&gt;vertexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY);
<a name="l00193"></a>00193          vertBinding-&gt;setBinding(i, buffer);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195          vertexBuffers.push_back(static_cast&lt;uchar*&gt;(buffer-&gt;lock(HardwareBuffer::HBL_DISCARD)));
<a name="l00196"></a>00196          vertexBufferElements.push_back(vertDecl-&gt;findElementsBySource(i));
<a name="l00197"></a>00197       }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199       m_ptrMaterial-&gt;getTechnique(0)-&gt;getPass(0)-&gt;setVertexColourTracking(TVC_AMBIENT);
<a name="l00200"></a>00200    }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="comment">//For each queued mesh...</span>
<a name="l00205"></a>00205     <span class="keywordtype">size_t</span> indexOffset = 0;
<a name="l00206"></a>00206    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iMesh = 0, meshCnt = m_queueMesh.size(); iMesh &lt; meshCnt; ++iMesh)
<a name="l00207"></a>00207    {
<a name="l00208"></a>00208         <span class="keyword">const</span> <a class="code" href="structForests_1_1BatchedGeometry_1_1SubBatch_1_1QueuedMesh.html">QueuedMesh</a> &amp;queuedMesh = m_queueMesh[iMesh];
<a name="l00209"></a>00209       <span class="keyword">const</span> Ogre::Vector3 &amp;scale = queuedMesh.scale;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         <span class="keyword">const</span> IndexData *sourceIndexData = queuedMesh.subMesh-&gt;indexData;
<a name="l00212"></a>00212         <span class="keyword">const</span> VertexData *sourceVertexData = queuedMesh.subMesh-&gt;vertexData;
<a name="l00213"></a>00213         Entity * ent = <span class="keyword">static_cast&lt;</span>Ogre::Entity*<span class="keyword">&gt;</span>(queuedMesh.userData);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215       <span class="keyword">static</span> <span class="keyword">const</span> Ogre::String c_windFactorX = <span class="stringliteral">&quot;windFactorX&quot;</span>, c_windFactorY = <span class="stringliteral">&quot;windFactorY&quot;</span>;
<a name="l00216"></a>00216         <span class="keywordtype">float</span> factorX = <span class="keyword">static_cast&lt;</span><a class="code" href="classForests_1_1WindBatchedGeometry.html" title="A variation of BatchedGeometry designed for WindBatchPage.">WindBatchedGeometry</a>*<span class="keyword">&gt;</span>(m_pParentGeom)-&gt;mGeom-&gt;getCustomParam(ent-&gt;getName(), c_windFactorX, 0.f);    <span class="comment">// amplitude in X</span>
<a name="l00217"></a>00217         <span class="keywordtype">float</span> factorY = <span class="keyword">static_cast&lt;</span><a class="code" href="classForests_1_1WindBatchedGeometry.html" title="A variation of BatchedGeometry designed for WindBatchPage.">WindBatchedGeometry</a>*<span class="keyword">&gt;</span>(m_pParentGeom)-&gt;mGeom-&gt;getCustomParam(ent-&gt;getName(), c_windFactorY, 0.f);    <span class="comment">// amplitude in Y</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219       Ogre::Real invMaxHeight = Ogre::Real(1.) / ent-&gt;getBoundingBox().getMaximum().y;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         <span class="comment">//Copy mesh vertex data into the vertex buffer</span>
<a name="l00222"></a>00222         VertexBufferBinding *sourceBinds = sourceVertexData-&gt;vertexBufferBinding;
<a name="l00223"></a>00223         VertexBufferBinding *destBinds = m_pVertexData-&gt;vertexBufferBinding;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225       <span class="comment">// SVA speed up. Rotate 3d vector by matrix 3x3 instead of quaternion</span>
<a name="l00226"></a>00226       Ogre::Matrix3 m3MeshRotation;
<a name="l00227"></a>00227       queuedMesh.orientation.ToRotationMatrix(m3MeshRotation);
<a name="l00228"></a>00228       Ogre::Real *mat = m3MeshRotation[0]; <span class="comment">// Ogre::Matrix is row major</span>
<a name="l00229"></a>00229       Ogre::Vector3 v3AddBatchCenter = queuedMesh.position - batchCenter;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231         <span class="keywordflow">for</span> (Ogre::ushort i = 0; i &lt; destBinds-&gt;getBufferCount(); ++i)
<a name="l00232"></a>00232         {
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (i &lt; sourceBinds-&gt;getBufferCount())
<a name="l00234"></a>00234          {
<a name="l00235"></a>00235                 <span class="comment">//Lock the input buffer</span>
<a name="l00236"></a>00236                 <span class="keyword">const</span> HardwareVertexBufferSharedPtr &amp;sourceBuffer = sourceBinds-&gt;getBuffer(i);
<a name="l00237"></a>00237                 uchar *sourceBase = <span class="keyword">static_cast&lt;</span>uchar*<span class="keyword">&gt;</span>(sourceBuffer-&gt;lock(HardwareBuffer::HBL_READ_ONLY));
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             <span class="keywordtype">size_t</span> sourceVertexSize = sourceBuffer-&gt;getVertexSize();
<a name="l00240"></a>00240             <span class="keywordtype">size_t</span> destVertexSize   = vertDecl-&gt;getVertexSize(i);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242                 <span class="comment">//Get the locked output buffer</span>
<a name="l00243"></a>00243                 uchar *destBase = vertexBuffers[i];
<a name="l00244"></a>00244 
<a name="l00245"></a>00245             <span class="keyword">const</span> VertexDeclaration::VertexElementList &amp;elems = vertexBufferElements[i];
<a name="l00246"></a>00246             VertexDeclaration::VertexElementList::const_iterator iBegin = elems.begin(), iEnd = elems.end();
<a name="l00247"></a>00247             <span class="comment">// vector to stock the original y value of every vertex because batchCenter doesn&#39;t take consider the height of the ground</span>
<a name="l00248"></a>00248             Ogre::Vector3 vertexPos;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250             <span class="comment">//Copy vertices</span>
<a name="l00251"></a>00251             <span class="keywordtype">float</span> *sourcePtr = 0, *destPtr = 0;
<a name="l00252"></a>00252                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0, vertexCount = sourceVertexData-&gt;vertexCount; v &lt; vertexCount; ++v)
<a name="l00253"></a>00253                 {
<a name="l00254"></a>00254                VertexDeclaration::VertexElementList::const_iterator itElement = iBegin;
<a name="l00255"></a>00255                <span class="comment">// Iterate over vertex elements</span>
<a name="l00256"></a>00256                     <span class="keywordflow">for</span> ( ; itElement != iEnd; ++itElement)
<a name="l00257"></a>00257                     {
<a name="l00258"></a>00258                         <span class="keyword">const</span> VertexElement &amp;elem = *itElement;
<a name="l00259"></a>00259                         elem.baseVertexPointerToElement(sourceBase, &amp;sourcePtr);
<a name="l00260"></a>00260                         elem.baseVertexPointerToElement(destBase, &amp;destPtr);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262                         <span class="keywordflow">switch</span> (elem.getSemantic())
<a name="l00263"></a>00263                         {
<a name="l00264"></a>00264                         <span class="keywordflow">case</span> VES_POSITION:
<a name="l00265"></a>00265                      {
<a name="l00266"></a>00266                         Ogre::Vector3 tmp(sourcePtr[0] * scale.x, sourcePtr[1] * scale.y, sourcePtr[2] * scale.z);
<a name="l00267"></a>00267                         <span class="comment">// rotate vector by matrix. Ogre::Matrix3::operator* (const Vector3&amp;) is not fast</span>
<a name="l00268"></a>00268                         vertexPos.x = mat[0] * tmp.x + mat[1] * tmp.y + mat[2] * tmp.z;
<a name="l00269"></a>00269                         vertexPos.y = mat[3] * tmp.x + mat[4] * tmp.y + mat[5] * tmp.z;
<a name="l00270"></a>00270                         vertexPos.z = mat[6] * tmp.x + mat[7] * tmp.y + mat[8] * tmp.z;
<a name="l00271"></a>00271                         tmp = vertexPos + v3AddBatchCenter;
<a name="l00272"></a>00272                         destPtr[0] = (float)tmp.x;
<a name="l00273"></a>00273                         destPtr[1] = (<span class="keywordtype">float</span>)tmp.y;
<a name="l00274"></a>00274                         destPtr[2] = (float)tmp.z;
<a name="l00275"></a>00275                      }
<a name="l00276"></a>00276                             <span class="keywordflow">break</span>;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278                   <span class="keywordflow">case</span> VES_NORMAL:
<a name="l00279"></a>00279                   <span class="keywordflow">case</span> VES_BINORMAL:
<a name="l00280"></a>00280                   <span class="keywordflow">case</span> VES_TANGENT:
<a name="l00281"></a>00281                      {
<a name="l00282"></a>00282                         <span class="comment">// rotate vector by matrix. Ogre::Matrix3::operator* (const Vector3&amp;) is not fast</span>
<a name="l00283"></a>00283                         destPtr[0] = float(mat[0] * sourcePtr[0] + mat[1] * sourcePtr[1] + mat[2] * sourcePtr[2]);   <span class="comment">// x</span>
<a name="l00284"></a>00284                         destPtr[1] = float(mat[3] * sourcePtr[0] + mat[4] * sourcePtr[1] + mat[5] * sourcePtr[2]);   <span class="comment">// y</span>
<a name="l00285"></a>00285                         destPtr[2] = float(mat[6] * sourcePtr[0] + mat[6] * sourcePtr[1] + mat[6] * sourcePtr[2]);   <span class="comment">// z</span>
<a name="l00286"></a>00286                      }
<a name="l00287"></a>00287                      <span class="keywordflow">break</span>;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289                         <span class="keywordflow">case</span> VES_DIFFUSE:
<a name="l00290"></a>00290                      {
<a name="l00291"></a>00291                         Ogre::uint32 tmpColor = *(<span class="keyword">reinterpret_cast&lt;</span>uint32*<span class="keyword">&gt;</span>(sourcePtr));
<a name="l00292"></a>00292                         Ogre::uint8 tmpR = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>((tmpColor &amp; 0xFF) * queuedMesh.color.r);
<a name="l00293"></a>00293                         Ogre::uint8 tmpG = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(((tmpColor &gt;&gt; 8) &amp; 0xFF)  * queuedMesh.color.g);
<a name="l00294"></a>00294                         Ogre::uint8 tmpB = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(((tmpColor &gt;&gt; 16) &amp; 0xFF) * queuedMesh.color.b);
<a name="l00295"></a>00295                         Ogre::uint8 tmpA = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(((tmpColor &gt;&gt; 24) &amp; 0xFF) * queuedMesh.color.a);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297                         tmpColor = tmpR | (tmpG &lt;&lt; 8) | (tmpB &lt;&lt; 16) | (tmpA &lt;&lt; 24);
<a name="l00298"></a>00298                         *(<span class="keyword">reinterpret_cast&lt;</span>uint32*<span class="keyword">&gt;</span>(destPtr)) = tmpColor;
<a name="l00299"></a>00299                      }
<a name="l00300"></a>00300                             <span class="keywordflow">break</span>;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302                         <span class="keywordflow">case</span> VES_TEXTURE_COORDINATES:
<a name="l00303"></a>00303                      {
<a name="l00304"></a>00304                         <span class="keywordflow">if</span> (elem.getIndex() == texCoordCount)
<a name="l00305"></a>00305                         {
<a name="l00306"></a>00306                            <span class="comment">// parameters to be passed to the shader</span>
<a name="l00307"></a>00307                            destPtr[0] = float(vertexPos.x);                <span class="comment">// radius coefficient</span>
<a name="l00308"></a>00308                            destPtr[1] = float(vertexPos.y * invMaxHeight); <span class="comment">// height coefficient</span>
<a name="l00309"></a>00309                            destPtr[2] = factorX;
<a name="l00310"></a>00310                            destPtr[3] = factorY;
<a name="l00311"></a>00311                         }
<a name="l00312"></a>00312                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (elem.getIndex() == texCoordCount + 1)
<a name="l00313"></a>00313                         {
<a name="l00314"></a>00314                            <span class="comment">// original position for each vertex</span>
<a name="l00315"></a>00315                            destPtr[0] = (float)queuedMesh.position.x;
<a name="l00316"></a>00316                            destPtr[1] = (<span class="keywordtype">float</span>)queuedMesh.position.y;
<a name="l00317"></a>00317                            destPtr[2] = (float)queuedMesh.position.z;
<a name="l00318"></a>00318                            destPtr[3] = 0.f;
<a name="l00319"></a>00319                         }
<a name="l00320"></a>00320                         <span class="keywordflow">else</span>
<a name="l00321"></a>00321                            <span class="comment">//memcpy(destPtr, sourcePtr, VertexElement::getTypeSize(elem.getType()));</span>
<a name="l00322"></a>00322                            memcpy(destPtr, sourcePtr, <a class="code" href="classForests_1_1BatchedGeometry.html#a67bb6db7722f592e2f7365d9e9a0aef2" title="Internal matrix for remap vertex type to vertex size instead call VertexElement::getTypeSize.">s_vertexType2Size</a>[elem.getType()]);
<a name="l00323"></a>00323                      }                  
<a name="l00324"></a>00324                      <span class="keywordflow">break</span>; 
<a name="l00325"></a>00325 
<a name="l00326"></a>00326                         <span class="keywordflow">default</span>:
<a name="l00327"></a>00327                             <span class="comment">//Raw copy</span>
<a name="l00328"></a>00328                             <span class="comment">//memcpy(destPtr, sourcePtr, VertexElement::getTypeSize(elem.getType()));</span>
<a name="l00329"></a>00329                      memcpy(destPtr, sourcePtr, <a class="code" href="classForests_1_1BatchedGeometry.html#a67bb6db7722f592e2f7365d9e9a0aef2" title="Internal matrix for remap vertex type to vertex size instead call VertexElement::getTypeSize.">s_vertexType2Size</a>[elem.getType()]);
<a name="l00330"></a>00330                             <span class="keywordflow">break</span>;
<a name="l00331"></a>00331                         };
<a name="l00332"></a>00332                     }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334                     <span class="comment">// Increment both pointers</span>
<a name="l00335"></a>00335                     destBase    += destVertexSize;
<a name="l00336"></a>00336                     sourceBase  += sourceVertexSize;
<a name="l00337"></a>00337                 }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339                 <span class="comment">//Unlock the input buffer</span>
<a name="l00340"></a>00340                 vertexBuffers[i] = destBase;
<a name="l00341"></a>00341                 sourceBuffer-&gt;unlock();
<a name="l00342"></a>00342          }
<a name="l00343"></a>00343          <span class="keywordflow">else</span>
<a name="l00344"></a>00344          {
<a name="l00345"></a>00345                 assert(m_RequireVertexColors);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347                 <span class="comment">//Get the locked output buffer</span>
<a name="l00348"></a>00348                 uint32 *startPtr = (uint32*)vertexBuffers[vertBinding-&gt;getBufferCount()-1];
<a name="l00349"></a>00349                 uint32 *endPtr = startPtr + sourceVertexData-&gt;vertexCount;
<a name="l00350"></a>00350                 
<a name="l00351"></a>00351                 <span class="comment">//Generate color</span>
<a name="l00352"></a>00352                 uint8 tmpR = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(queuedMesh.color.r * 255);
<a name="l00353"></a>00353                 uint8 tmpG = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(queuedMesh.color.g * 255);
<a name="l00354"></a>00354                 uint8 tmpB = <span class="keyword">static_cast&lt;</span>uint8<span class="keyword">&gt;</span>(queuedMesh.color.b * 255);
<a name="l00355"></a>00355                 uint32 tmpColor = tmpR | (tmpG &lt;&lt; 8) | (tmpB &lt;&lt; 16) | (0xFF &lt;&lt; 24);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357                 <span class="comment">//Copy colors</span>
<a name="l00358"></a>00358                 <span class="keywordflow">while</span> (startPtr &lt; endPtr)
<a name="l00359"></a>00359             {
<a name="l00360"></a>00360                     *startPtr++ = tmpColor;
<a name="l00361"></a>00361                 }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363                 vertexBuffers[vertBinding-&gt;getBufferCount()-1] += (<span class="keyword">sizeof</span>(uint32) * sourceVertexData-&gt;vertexCount);
<a name="l00364"></a>00364          }
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         <span class="comment">//Copy mesh index data into the index buffer</span>
<a name="l00369"></a>00369         <span class="keywordflow">if</span> (srcIndexType == HardwareIndexBuffer::IT_32BIT)
<a name="l00370"></a>00370       {
<a name="l00371"></a>00371             <span class="comment">//Lock the input buffer</span>
<a name="l00372"></a>00372             uint32 *source = <span class="keyword">static_cast&lt;</span>uint32*<span class="keyword">&gt;</span>(sourceIndexData-&gt;indexBuffer-&gt;lock(
<a name="l00373"></a>00373                 sourceIndexData-&gt;indexStart, sourceIndexData-&gt;indexCount, HardwareBuffer::HBL_READ_ONLY));
<a name="l00374"></a>00374             uint32 *sourceEnd = source + sourceIndexData-&gt;indexCount;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376             <span class="comment">//And copy it to the output buffer</span>
<a name="l00377"></a>00377             <span class="keywordflow">while</span> (source != sourceEnd) {
<a name="l00378"></a>00378                 *indexBuffer32++ = <span class="keyword">static_cast&lt;</span>uint32<span class="keyword">&gt;</span>(*source++ + indexOffset);
<a name="l00379"></a>00379             }
<a name="l00380"></a>00380             
<a name="l00381"></a>00381             <span class="comment">//Unlock the input buffer</span>
<a name="l00382"></a>00382             sourceIndexData-&gt;indexBuffer-&gt;unlock();
<a name="l00383"></a>00383 
<a name="l00384"></a>00384             <span class="comment">//Increment the index offset</span>
<a name="l00385"></a>00385             indexOffset += sourceVertexData-&gt;vertexCount;
<a name="l00386"></a>00386         }
<a name="l00387"></a>00387       <span class="keywordflow">else</span>
<a name="l00388"></a>00388       {
<a name="l00389"></a>00389             <span class="keywordflow">if</span> (destIndexType == HardwareIndexBuffer::IT_32BIT)
<a name="l00390"></a>00390          {
<a name="l00391"></a>00391                 <span class="comment">//-- Convert 16 bit to 32 bit indices --</span>
<a name="l00392"></a>00392                 <span class="comment">//Lock the input buffer</span>
<a name="l00393"></a>00393                 uint16 *source = <span class="keyword">static_cast&lt;</span>uint16*<span class="keyword">&gt;</span>(sourceIndexData-&gt;indexBuffer-&gt;lock(
<a name="l00394"></a>00394                     sourceIndexData-&gt;indexStart, sourceIndexData-&gt;indexCount, HardwareBuffer::HBL_READ_ONLY
<a name="l00395"></a>00395                     ));
<a name="l00396"></a>00396                 uint16 *sourceEnd = source + sourceIndexData-&gt;indexCount;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398                 <span class="comment">//And copy it to the output buffer</span>
<a name="l00399"></a>00399                 <span class="keywordflow">while</span> (source != sourceEnd) {
<a name="l00400"></a>00400                     uint32 indx = *source++;
<a name="l00401"></a>00401                     *indexBuffer32++ = (indx + indexOffset);
<a name="l00402"></a>00402                 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                 <span class="comment">//Unlock the input buffer</span>
<a name="l00405"></a>00405                 sourceIndexData-&gt;indexBuffer-&gt;unlock();
<a name="l00406"></a>00406 
<a name="l00407"></a>00407                 <span class="comment">//Increment the index offset</span>
<a name="l00408"></a>00408                 indexOffset += sourceVertexData-&gt;vertexCount;
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410          <span class="keywordflow">else</span>
<a name="l00411"></a>00411          {
<a name="l00412"></a>00412                 <span class="comment">//Lock the input buffer</span>
<a name="l00413"></a>00413                 uint16 *source = <span class="keyword">static_cast&lt;</span>uint16*<span class="keyword">&gt;</span>(sourceIndexData-&gt;indexBuffer-&gt;lock(
<a name="l00414"></a>00414                     sourceIndexData-&gt;indexStart, sourceIndexData-&gt;indexCount, HardwareBuffer::HBL_READ_ONLY
<a name="l00415"></a>00415                     ));
<a name="l00416"></a>00416                 uint16 *sourceEnd = source + sourceIndexData-&gt;indexCount;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418                 <span class="comment">//And copy it to the output buffer</span>
<a name="l00419"></a>00419                 <span class="keywordflow">while</span> (source != sourceEnd)
<a name="l00420"></a>00420             {
<a name="l00421"></a>00421                     *indexBuffer16++ = <span class="keyword">static_cast&lt;</span>uint16<span class="keyword">&gt;</span>(*source++ + indexOffset);
<a name="l00422"></a>00422                 }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424                 <span class="comment">//Unlock the input buffer</span>
<a name="l00425"></a>00425                 sourceIndexData-&gt;indexBuffer-&gt;unlock();
<a name="l00426"></a>00426 
<a name="l00427"></a>00427                 <span class="comment">//Increment the index offset</span>
<a name="l00428"></a>00428                 indexOffset += sourceVertexData-&gt;vertexCount;
<a name="l00429"></a>00429             }
<a name="l00430"></a>00430         }
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">//Unlock buffers</span>
<a name="l00434"></a>00434     m_pIndexData-&gt;indexBuffer-&gt;unlock();
<a name="l00435"></a>00435     <span class="keywordflow">for</span> (Ogre::ushort i = 0; i &lt; vertBinding-&gt;getBufferCount(); ++i)
<a name="l00436"></a>00436         vertBinding-&gt;getBuffer(i)-&gt;unlock();
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     m_queueMesh.clear();
<a name="l00439"></a>00439     m_Built = <span class="keyword">true</span>;
<a name="l00440"></a>00440 }
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 19 2013 09:55:43 for PagedGeometry by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
