<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>PagedGeometry: /home/thomas/meteor-falls/meteor-falls-src/libs/ogre-paged/include/PagedGeometry.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">PagedGeometry
   &#160;<span id="projectnumber">1.1.4</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/thomas/meteor-falls/meteor-falls-src/libs/ogre-paged/include/PagedGeometry.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*-------------------------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2006 John Judnich</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00005"></a>00005 <span class="comment">Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:</span>
<a name="l00006"></a>00006 <span class="comment">    1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00007"></a>00007 <span class="comment">    2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00008"></a>00008 <span class="comment">    3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00009"></a>00009 <span class="comment">-------------------------------------------------------------------------------------*/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;PagedGeometryConfig.h&quot;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="comment">//PagedGeometry.h</span>
<a name="l00014"></a>00014 <span class="comment">//Main header file for the PagedGeometry engine.</span>
<a name="l00015"></a>00015 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">//-------- The following is the main API documentation page (parsed by doxygen) --------</span>
<a name="l00091"></a>00091 <span class="comment"></span><span class="comment">//--------------------------------------------------------------------------------------</span>
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">// this small snipped disables some warnings under MSVC that can be ignored normally</span>
<a name="l00094"></a>00094 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="comment">// disable MSVC warning &quot;... possible loss of data&quot;</span>
<a name="l00096"></a>00096 <span class="comment">//# pragma warning(disable: 4244)</span>
<a name="l00097"></a>00097 <span class="preprocessor">#endif //_MSC_VER</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="preprocessor">#ifndef __PagedGeometry_H__</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#define __PagedGeometry_H__</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="preprocessor">#include &lt;limits&gt;</span> <span class="comment">// numeric_limits&lt;&gt;</span>
<a name="l00104"></a>00104 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="preprocessor">#include &lt;OgreRoot.h&gt;</span>
<a name="l00107"></a>00107 <span class="preprocessor">#include &lt;OgrePrerequisites.h&gt;</span>
<a name="l00108"></a>00108 <span class="preprocessor">#include &lt;OgreRenderSystem.h&gt;</span>
<a name="l00109"></a>00109 <span class="preprocessor">#include &lt;OgreEntity.h&gt;</span>
<a name="l00110"></a>00110 <span class="preprocessor">#include &lt;OgreCommon.h&gt;</span>
<a name="l00111"></a>00111 <span class="preprocessor">#include &lt;OgreCamera.h&gt;</span>
<a name="l00112"></a>00112 <span class="preprocessor">#include &lt;OgreVector3.h&gt;</span>
<a name="l00113"></a>00113 <span class="preprocessor">#include &lt;OgreTimer.h&gt;</span>
<a name="l00114"></a>00114 <span class="preprocessor">#include &lt;OgreMesh.h&gt;</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">namespace </span>Forests {
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">class </span>GeometryPageManager;
<a name="l00119"></a>00119 <span class="keyword">class </span>PageLoader;
<a name="l00120"></a>00120 
<a name="l00122"></a>00122 <span class="keyword">typedef</span> Ogre::TRect&lt;Ogre::Real&gt; TBounds;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">//Enable PagedGeometry::setCoordinateSystem()</span>
<a name="l00125"></a>00125 <span class="comment">//#define PAGEDGEOMETRY_ALTERNATE_COORDSYSTEM</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">//Enable per-entity user-defined data and callbacks</span>
<a name="l00128"></a>00128 <span class="comment">//#define PAGEDGEOMETRY_USER_DATA</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l00153"></a>00153 <span class="comment"></span><span class="keyword">class </span>PagedGeometry
<a name="l00154"></a>00154 {
<a name="l00155"></a>00155 <span class="keyword">public</span>:
<a name="l00175"></a>00175     PagedGeometry(Ogre::Camera *cam = NULL, Ogre::Real pageSize = 100, Ogre::RenderQueueGroupID queue = Ogre::RENDER_QUEUE_6);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     ~PagedGeometry();
<a name="l00178"></a>00178 
<a name="l00191"></a>00191     <span class="keywordtype">void</span> setCamera(Ogre::Camera *cam);
<a name="l00192"></a>00192 
<a name="l00196"></a>00196     <span class="keywordtype">void</span> setTempDir(Ogre::String dir);
<a name="l00197"></a>00197     Ogre::String getTempdir() { <span class="keywordflow">return</span> this-&gt;tempdir; };
<a name="l00198"></a>00198 
<a name="l00208"></a>00208     <span class="keyword">inline</span> Ogre::Camera *getCamera()<span class="keyword"> const</span>
<a name="l00209"></a>00209 <span class="keyword">    </span>{
<a name="l00210"></a>00210         <span class="keywordflow">return</span> sceneCam;
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212 
<a name="l00223"></a>00223     <span class="keyword">inline</span> Ogre::SceneManager *getSceneManager()<span class="keyword"> const</span>
<a name="l00224"></a>00224 <span class="keyword">    </span>{
<a name="l00225"></a>00225         <span class="keywordflow">return</span> sceneMgr;
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227 
<a name="l00248"></a>00248     <span class="keyword">inline</span> Ogre::SceneNode *getSceneNode()<span class="keyword"> const</span>
<a name="l00249"></a>00249 <span class="keyword">    </span>{
<a name="l00250"></a>00250         <span class="keywordflow">return</span> rootNode;
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="preprocessor">    #ifdef PAGEDGEOMETRY_ALTERNATE_COORDSYSTEM</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>
<a name="l00277"></a>00277     <span class="keywordtype">void</span> setCoordinateSystem(Ogre::Vector3 up, Ogre::Vector3 right = Ogre::Vector3::UNIT_X);
<a name="l00278"></a>00278 <span class="preprocessor">    #endif</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>
<a name="l00300"></a>00300     <span class="keywordtype">void</span> setBounds(<span class="keyword">const</span> TBounds bounds);
<a name="l00301"></a>00301 
<a name="l00321"></a>00321     <span class="keywordtype">void</span> setInfinite();
<a name="l00322"></a>00322 
<a name="l00341"></a>00341     <span class="keyword">inline</span> <span class="keyword">const</span> TBounds &amp;getBounds()<span class="keyword"> const</span>
<a name="l00342"></a>00342 <span class="keyword">    </span>{
<a name="l00343"></a>00343         <span class="keywordflow">return</span> m_bounds;
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345 
<a name="l00349"></a>00349     TBounds convertAABToTBounds( <span class="keyword">const</span> Ogre::AxisAlignedBox &amp; aab ) <span class="keyword">const</span>;
<a name="l00350"></a>00350 
<a name="l00362"></a>00362     <span class="keywordtype">void</span> setPageSize(Ogre::Real size);
<a name="l00363"></a>00363 
<a name="l00370"></a>00370     <span class="keyword">inline</span> Ogre::Real getPageSize()
<a name="l00371"></a>00371     {
<a name="l00372"></a>00372         <span class="keywordflow">return</span> pageSize;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 
<a name="l00469"></a>00469     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PageType&gt; <span class="keyword">inline</span> GeometryPageManager* addDetailLevel(Ogre::Real maxRange, Ogre::Real transitionLength = 0, <span class="keyword">const</span> Ogre::Any &amp;data = Ogre::Any(), Ogre::uint32 queryFlag = 0);
<a name="l00470"></a>00470 
<a name="l00479"></a>00479     <span class="keywordtype">void</span> removeDetailLevels();
<a name="l00480"></a>00480 
<a name="l00489"></a>00489     <span class="keyword">inline</span> <span class="keyword">const</span> std::list&lt;GeometryPageManager*&gt; &amp;getDetailLevels() { <span class="keywordflow">return</span> managerList; }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 
<a name="l00507"></a>00507     <span class="keywordtype">void</span> setPageLoader(PageLoader *loader);
<a name="l00508"></a>00508 
<a name="l00516"></a>00516     <span class="keyword">inline</span> PageLoader *getPageLoader()
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518         <span class="keywordflow">return</span> pageLoader;
<a name="l00519"></a>00519     }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 
<a name="l00530"></a>00530     <span class="keywordtype">void</span> update();
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 
<a name="l00545"></a>00545     <span class="keywordtype">void</span> reloadGeometry();
<a name="l00546"></a>00546 
<a name="l00567"></a>00567     <span class="keywordtype">void</span> reloadGeometryPage(<span class="keyword">const</span> Ogre::Vector3 &amp;point);
<a name="l00568"></a>00568 
<a name="l00593"></a>00593     <span class="keywordtype">void</span> reloadGeometryPages(<span class="keyword">const</span> Ogre::Vector3 &amp;center, Ogre::Real radius);
<a name="l00594"></a>00594 
<a name="l00618"></a>00618     <span class="keywordtype">void</span> reloadGeometryPages(<span class="keyword">const</span> TBounds &amp; area);
<a name="l00619"></a>00619 
<a name="l00635"></a>00635     <span class="keywordtype">void</span> preloadGeometry(<span class="keyword">const</span> TBounds &amp; area);
<a name="l00636"></a>00636 
<a name="l00649"></a>00649     <span class="keywordtype">void</span> resetPreloadedGeometry();
<a name="l00650"></a>00650 
<a name="l00658"></a>00658     <span class="keywordtype">void</span> setVisible(<span class="keywordtype">bool</span> visible) { geometryAllowedVisible = visible; }
<a name="l00659"></a>00659 
<a name="l00666"></a>00666     <span class="keywordtype">bool</span> getVisible() { <span class="keywordflow">return</span> geometryAllowedVisible; }
<a name="l00667"></a>00667 
<a name="l00671"></a>00671     <span class="keywordtype">void</span> setShadersEnabled(<span class="keywordtype">bool</span> value) { shadersEnabled=value; }
<a name="l00672"></a>00672     <span class="keywordtype">bool</span> getShadersEnabled() { <span class="keywordflow">return</span> shadersEnabled; }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="comment">/*</span>
<a name="l00675"></a>00675 <span class="comment">    \brief Immediately loads visible geometry.</span>
<a name="l00676"></a>00676 <span class="comment">    \param maxTime The maximum amount of time (in milliseconds) which cacheGeometry()</span>
<a name="l00677"></a>00677 <span class="comment">    is allowed to use before returning (roughly).</span>
<a name="l00678"></a>00678 <span class="comment">    \returns Whether or not everything was cached.</span>
<a name="l00679"></a>00679 <span class="comment"></span>
<a name="l00680"></a>00680 <span class="comment">    PagedGeometry automatically loads and caches geometry near the camera in real-time.</span>
<a name="l00681"></a>00681 <span class="comment">    This function allows you to easily pre-load this geometry outside of your render loop.</span>
<a name="l00682"></a>00682 <span class="comment"></span>
<a name="l00683"></a>00683 <span class="comment">    For example, in your loading code, you might call PagedGeometry::cacheGeometry() to</span>
<a name="l00684"></a>00684 <span class="comment">    load all your trees/etc. managed by PagedGeometry instantly, rather than later on.</span>
<a name="l00685"></a>00685 <span class="comment"></span>
<a name="l00686"></a>00686 <span class="comment">    If it takes several seconds to cache geometry, you may want to update a progress bar</span>
<a name="l00687"></a>00687 <span class="comment">    more often. The maxTime parameter allows you to split up this task into smaller</span>
<a name="l00688"></a>00688 <span class="comment">    segments for this purpose. Simply call cacheGeometry(maxTime) repeatedly until</span>
<a name="l00689"></a>00689 <span class="comment">    everything is cached (cacheGeometry() will return true when finished ).</span>
<a name="l00690"></a>00690 <span class="comment">    */</span>
<a name="l00691"></a>00691     <span class="comment">//todo</span>
<a name="l00692"></a>00692     <span class="comment">//bool cacheGeometry(unsigned long maxTime = 0);</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 
<a name="l00696"></a>00696     Ogre::Vector3 _convertToLocal(<span class="keyword">const</span> Ogre::Vector3 &amp;globalVec) <span class="keyword">const</span>;
<a name="l00697"></a>00697 
<a name="l00716"></a>00716     <span class="keywordtype">void</span> setCustomParam(<span class="keyword">const</span> Ogre::String &amp;entity, <span class="keyword">const</span> Ogre::String &amp;paramName, <span class="keywordtype">float</span> paramValue);
<a name="l00717"></a>00717 
<a name="l00736"></a>00736     <span class="keywordtype">void</span> setCustomParam(<span class="keyword">const</span> Ogre::String &amp;paramName, <span class="keywordtype">float</span> paramValue);
<a name="l00737"></a>00737 
<a name="l00745"></a>00745     <span class="keywordtype">float</span> getCustomParam(<span class="keyword">const</span> Ogre::String &amp;entity, <span class="keyword">const</span> Ogre::String &amp;paramName, <span class="keywordtype">float</span> defaultParamValue) <span class="keyword">const</span>;
<a name="l00746"></a>00746 
<a name="l00754"></a>00754     <span class="keywordtype">float</span> getCustomParam(<span class="keyword">const</span> Ogre::String &amp;paramName, <span class="keywordtype">float</span> defaultParamValue) <span class="keyword">const</span>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 
<a name="l00758"></a>00758    Ogre::uint8 getRenderQueue()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> m_nRenderQueue; }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 <span class="keyword">protected</span>:
<a name="l00761"></a>00761     <span class="comment">//Internal function - do not use</span>
<a name="l00762"></a>00762     <span class="keywordtype">void</span> _addDetailLevel(GeometryPageManager *mgr, Ogre::Real maxRange, Ogre::Real transitionLength);
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     Ogre::SceneManager *sceneMgr;
<a name="l00765"></a>00765     Ogre::SceneNode *rootNode;              <span class="comment">//PagedGeometry&#39;s own &quot;root&quot; node</span>
<a name="l00766"></a>00766     <span class="keywordtype">bool</span> shadersEnabled;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     <span class="keywordtype">bool</span> geometryAllowedVisible;    <span class="comment">//If set to false, all geometry managed by this PagedGeometry is hidden</span>
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="preprocessor">    #ifdef PAGEDGEOMETRY_ALTERNATE_COORDSYSTEM</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>    Ogre::Quaternion coordinateSystemQuat;  <span class="comment">//The orientation of rootNode</span>
<a name="l00772"></a>00772 <span class="preprocessor">    #endif</span>
<a name="l00773"></a>00773 <span class="preprocessor"></span>
<a name="l00774"></a>00774     <span class="comment">//Camera data</span>
<a name="l00775"></a>00775     Ogre::Camera *sceneCam;
<a name="l00776"></a>00776     Ogre::Vector3 oldCamPos;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     Ogre::Camera *lastSceneCam;
<a name="l00779"></a>00779     Ogre::Vector3 lastOldCamPos;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781     <span class="comment">//This list keeps track of all the GeometryPageManager&#39;s added with addPageManager()</span>
<a name="l00782"></a>00782     std::list&lt;GeometryPageManager*&gt; managerList;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="comment">//The assigned PageLoader used to load entities</span>
<a name="l00785"></a>00785     PageLoader *pageLoader;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     <span class="comment">//The bounds and page size</span>
<a name="l00788"></a>00788     TBounds m_bounds;
<a name="l00789"></a>00789     <span class="comment">//The page size</span>
<a name="l00790"></a>00790     Ogre::Real pageSize;
<a name="l00791"></a>00791    Ogre::uint8 m_nRenderQueue;   
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="comment">//Time-related data</span>
<a name="l00794"></a>00794     Ogre::Timer timer;
<a name="l00795"></a>00795     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lastTime;
<a name="l00796"></a>00796     Ogre::String tempdir;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="keyword">private</span>:
<a name="l00799"></a>00799    <span class="keyword">typedef</span> std::map &lt;Ogre::String, float&gt; TStr2FloatMap;
<a name="l00800"></a>00800     TStr2FloatMap  m_mapCustomParam;
<a name="l00801"></a>00801 };
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l00863"></a>00863 <span class="comment"></span><span class="keyword">class </span>GeometryPage
<a name="l00864"></a>00864 {
<a name="l00865"></a>00865     <span class="keyword">friend</span> <span class="keyword">class </span>GeometryPageManager;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="keyword">public</span>:
<a name="l00888"></a>00888     <span class="keyword">virtual</span> <span class="keywordtype">void</span> init(PagedGeometry *geom, <span class="keyword">const</span> Ogre::Any &amp;data) = 0;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890     <span class="keywordtype">void</span> setQueryFlag(Ogre::uint32 flag)
<a name="l00891"></a>00891     {
<a name="l00892"></a>00892         mHasQueryFlag = <span class="keyword">true</span>;
<a name="l00893"></a>00893         mQueryFlag = flag;
<a name="l00894"></a>00894     };
<a name="l00895"></a>00895 
<a name="l00896"></a>00896     <span class="keywordtype">bool</span> hasQueryFlag()
<a name="l00897"></a>00897     {
<a name="l00898"></a>00898         <span class="keywordflow">return</span> mHasQueryFlag;
<a name="l00899"></a>00899     };
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     Ogre::uint32 getQueryFlag()
<a name="l00902"></a>00902     {
<a name="l00903"></a>00903         <span class="keywordflow">return</span> mQueryFlag;
<a name="l00904"></a>00904     };
<a name="l00905"></a>00905 
<a name="l00923"></a>00923     <span class="keyword">virtual</span> <span class="keywordtype">void</span> setRegion(Ogre::Real left, Ogre::Real top, Ogre::Real right, Ogre::Real bottom) {};
<a name="l00924"></a>00924 
<a name="l00940"></a>00940     <span class="keyword">virtual</span> <span class="keywordtype">void</span> addEntity(Ogre::Entity *ent, <span class="keyword">const</span> Ogre::Vector3 &amp;position, <span class="keyword">const</span> Ogre::Quaternion &amp;rotation, <span class="keyword">const</span> Ogre::Vector3 &amp;scale, <span class="keyword">const</span> Ogre::ColourValue &amp;color) = 0;
<a name="l00941"></a>00941 
<a name="l00952"></a>00952     <span class="keyword">virtual</span> <span class="keywordtype">void</span> build() {}
<a name="l00953"></a>00953 
<a name="l00967"></a>00967     <span class="keyword">virtual</span> <span class="keywordtype">void</span> removeEntities() = 0;
<a name="l00968"></a>00968 
<a name="l00986"></a>00986     <span class="keyword">virtual</span> <span class="keywordtype">void</span> setFade(<span class="keywordtype">bool</span> enabled, Ogre::Real visibleDist = 0, Ogre::Real invisibleDist = 0) = 0;
<a name="l00987"></a>00987 
<a name="l00992"></a>00992     <span class="keyword">virtual</span> <span class="keywordtype">void</span> setVisible(<span class="keywordtype">bool</span> visible) = 0;
<a name="l00993"></a>00993 
<a name="l01003"></a>01003     <span class="keyword">virtual</span> <span class="keywordtype">void</span> update() {}
<a name="l01004"></a>01004 
<a name="l01011"></a>01011     <span class="keyword">inline</span> Ogre::Vector3 &amp;getCenterPoint() { <span class="keywordflow">return</span> _centerPoint; }
<a name="l01012"></a>01012 
<a name="l01019"></a>01019     <span class="keyword">inline</span> <span class="keywordtype">bool</span> isVisible() { <span class="keywordflow">return</span> (_visible &amp;&amp; _loaded); }
<a name="l01020"></a>01020 
<a name="l01039"></a>01039     <span class="keyword">virtual</span> <span class="keyword">const</span> Ogre::AxisAlignedBox &amp;getBoundingBox();
<a name="l01040"></a>01040 
<a name="l01050"></a>01050     <span class="keyword">virtual</span> <span class="keywordtype">void</span> addEntityToBoundingBox(Ogre::Entity *ent, <span class="keyword">const</span> Ogre::Vector3 &amp;position, <span class="keyword">const</span> Ogre::Quaternion &amp;rotation, <span class="keyword">const</span> Ogre::Vector3 &amp;scale);
<a name="l01051"></a>01051 
<a name="l01061"></a>01061     <span class="keyword">virtual</span> <span class="keywordtype">void</span> clearBoundingBox();
<a name="l01062"></a>01062 
<a name="l01068"></a>01068     <span class="keyword">virtual</span> ~GeometryPage() {}
<a name="l01069"></a>01069 
<a name="l01074"></a>01074     GeometryPage();
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="keyword">private</span>:
<a name="l01077"></a>01077     <span class="comment">//These values and functions are used by the GeometryPageManager internally.</span>
<a name="l01078"></a>01078     Ogre::Vector3 _centerPoint;     <span class="comment">//The central point of this page (used to visibility calculation)</span>
<a name="l01079"></a>01079     <span class="keywordtype">int</span> _xIndex, _zIndex;           <span class="comment">//The absolute grid position of this page</span>
<a name="l01080"></a>01080     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> _inactiveTime;    <span class="comment">//How long this page has been inactive (used to calculate expired pages)</span>
<a name="l01081"></a>01081     <span class="keywordtype">bool</span> _visible;      <span class="comment">//Flag indicating if page is visible</span>
<a name="l01082"></a>01082     <span class="keywordtype">bool</span> _fadeEnable;   <span class="comment">//Flag indicating if page fading is enabled</span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084     <span class="keywordtype">bool</span> _pending;      <span class="comment">//Flag indicating if page needs loading</span>
<a name="l01085"></a>01085     <span class="keywordtype">bool</span> _loaded;       <span class="comment">//Flag indicating if page is loaded</span>
<a name="l01086"></a>01086     <span class="keywordtype">bool</span> _needsUnload;  <span class="comment">//Flag indicating if page needs unloading before next load</span>
<a name="l01087"></a>01087     <span class="keywordtype">bool</span> _keepLoaded;   <span class="comment">//Flag indicating if the page should not be unloaded</span>
<a name="l01088"></a>01088     std::list&lt;GeometryPage*&gt;::iterator _iter;   <span class="comment">//Iterator in loadedList</span>
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     Ogre::AxisAlignedBox _trueBounds;   <span class="comment">//Actual bounding box of the 3D geometry added to this page</span>
<a name="l01091"></a>01091     <span class="keywordtype">bool</span> _trueBoundsUndefined;          <span class="comment">//Flag indicating if _trueBounds has not been defined yet</span>
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     <span class="keywordtype">void</span> *_userData;    <span class="comment">//Misc. data associated with this page by the PageLoader</span>
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="keywordtype">bool</span> mHasQueryFlag;
<a name="l01096"></a>01096     Ogre::uint32 mQueryFlag;
<a name="l01097"></a>01097 };
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l01111"></a>01111 <span class="comment"></span><span class="keyword">struct </span>PageInfo
<a name="l01112"></a>01112 {
<a name="l01126"></a>01126     TBounds bounds;
<a name="l01127"></a>01127 
<a name="l01133"></a>01133     Ogre::Vector3 centerPoint;
<a name="l01134"></a>01134 
<a name="l01145"></a>01145     <span class="keywordtype">int</span> xIndex;
<a name="l01146"></a>01146 
<a name="l01157"></a>01157     <span class="keywordtype">int</span> zIndex;
<a name="l01158"></a>01158 
<a name="l01171"></a>01171     <span class="keywordtype">void</span> *userData;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     std::vector&lt;Ogre::Mesh*&gt; meshList;
<a name="l01174"></a>01174 };
<a name="l01175"></a>01175 
<a name="l01225"></a>01225 <span class="keyword">class </span>PageLoader
<a name="l01226"></a>01226 {
<a name="l01227"></a>01227 <span class="keyword">public</span>:
<a name="l01247"></a>01247     <span class="keyword">virtual</span> <span class="keywordtype">void</span> loadPage(PageInfo &amp;page) = 0;
<a name="l01248"></a>01248 
<a name="l01264"></a>01264     <span class="keyword">virtual</span> <span class="keywordtype">void</span> unloadPage(PageInfo &amp;page) {}
<a name="l01265"></a>01265 
<a name="l01279"></a>01279     <span class="keyword">virtual</span> <span class="keywordtype">void</span> frameUpdate() {}
<a name="l01280"></a>01280 
<a name="l01286"></a>01286     <span class="keyword">virtual</span> ~PageLoader() {}
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="keyword">protected</span>:
<a name="l01308"></a>01308     <span class="keywordtype">void</span> addEntity(Ogre::Entity *ent, <span class="keyword">const</span> Ogre::Vector3 &amp;position, <span class="keyword">const</span> Ogre::Quaternion &amp;rotation, <span class="keyword">const</span> Ogre::Vector3 &amp;scale = Ogre::Vector3::UNIT_SCALE, <span class="keyword">const</span> Ogre::ColourValue &amp;color = Ogre::ColourValue::White)
<a name="l01309"></a>01309     {
<a name="l01310"></a>01310         geomPage-&gt;addEntity(ent, position, rotation, scale, color);
<a name="l01311"></a>01311         geomPage-&gt;addEntityToBoundingBox(ent, position, rotation, scale);
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314 <span class="keyword">private</span>:
<a name="l01315"></a>01315     <span class="keyword">friend</span> <span class="keyword">class </span>GeometryPageManager;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">//Do NOT modify or use this variable - it is used internally by addEntity()</span>
<a name="l01318"></a>01318     GeometryPage *geomPage;
<a name="l01319"></a>01319 };
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l01343"></a>01343 <span class="comment"></span><span class="keyword">class </span>GeometryPageManager
<a name="l01344"></a>01344 {
<a name="l01345"></a>01345 <span class="keyword">public</span>:
<a name="l01347"></a>01347     <span class="keyword">typedef</span> std::list&lt;GeometryPage*&gt; TPGeometryPages;
<a name="l01348"></a>01348 
<a name="l01350"></a>01350     GeometryPageManager(PagedGeometry *mainGeom);
<a name="l01351"></a>01351 
<a name="l01353"></a>01353     ~GeometryPageManager();
<a name="l01354"></a>01354 
<a name="l01363"></a>01363     <span class="keyword">inline</span> <span class="keywordtype">void</span> setNearRange(Ogre::Real nearRange)
<a name="l01364"></a>01364     {
<a name="l01365"></a>01365         nearDist = nearRange;
<a name="l01366"></a>01366         nearDistSq = nearDist * nearDist;
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368 
<a name="l01377"></a>01377     <span class="keyword">inline</span> <span class="keywordtype">void</span> setFarRange(Ogre::Real farRange)
<a name="l01378"></a>01378     {
<a name="l01379"></a>01379         farDist = farRange;
<a name="l01380"></a>01380         farDistSq = farDist * farDist;
<a name="l01381"></a>01381 
<a name="l01382"></a>01382         farTransDist = farDist + fadeLength;
<a name="l01383"></a>01383         farTransDistSq = farTransDist * farTransDist;
<a name="l01384"></a>01384     }
<a name="l01385"></a>01385 
<a name="l01392"></a>01392     <span class="keyword">inline</span> Ogre::Real getNearRange()<span class="keyword"> const</span>
<a name="l01393"></a>01393 <span class="keyword">    </span>{
<a name="l01394"></a>01394         <span class="keywordflow">return</span> nearDist;
<a name="l01395"></a>01395     }
<a name="l01396"></a>01396 
<a name="l01403"></a>01403     <span class="keyword">inline</span> Ogre::Real getFarRange()<span class="keyword"> const</span>
<a name="l01404"></a>01404 <span class="keyword">    </span>{
<a name="l01405"></a>01405         <span class="keywordflow">return</span> farDist;
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407 
<a name="l01432"></a>01432     <span class="keyword">inline</span> <span class="keywordtype">void</span> setCacheSpeed(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxCacheInterval = 200, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> inactivePageLife = 2000)
<a name="l01433"></a>01433     {
<a name="l01434"></a>01434         GeometryPageManager::maxCacheInterval = maxCacheInterval;
<a name="l01435"></a>01435         GeometryPageManager::inactivePageLife = inactivePageLife;
<a name="l01436"></a>01436     }
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     <span class="keyword">inline</span> <span class="keywordtype">void</span> setTransition(Ogre::Real transitionLength)
<a name="l01439"></a>01439     {
<a name="l01440"></a>01440         <span class="keywordflow">if</span> (transitionLength &gt; 0) {
<a name="l01441"></a>01441             <span class="comment">//Setup valid transition</span>
<a name="l01442"></a>01442             fadeLength = transitionLength;
<a name="l01443"></a>01443             fadeLengthSq = fadeLength * fadeLength;
<a name="l01444"></a>01444             fadeEnabled = <span class="keyword">true</span>;
<a name="l01445"></a>01445         } <span class="keywordflow">else</span> {
<a name="l01446"></a>01446             <span class="comment">//&lt;= 0 indicates disabled transition</span>
<a name="l01447"></a>01447             fadeLength = 0;
<a name="l01448"></a>01448             fadeLengthSq = 0;
<a name="l01449"></a>01449             fadeEnabled = <span class="keyword">false</span>;
<a name="l01450"></a>01450         }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452         farTransDist = farDist + fadeLength;
<a name="l01453"></a>01453         farTransDistSq = farTransDist * farTransDist;
<a name="l01454"></a>01454     }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456     <span class="keyword">inline</span> Ogre::Real getTransition()<span class="keyword"> const</span>
<a name="l01457"></a>01457 <span class="keyword">    </span>{
<a name="l01458"></a>01458         <span class="keywordflow">return</span> fadeLength;
<a name="l01459"></a>01459     }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 
<a name="l01463"></a>01463     <span class="keyword">inline</span> TPGeometryPages getLoadedPages()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> loadedList; }
<a name="l01464"></a>01464 
<a name="l01466"></a>01466     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PageType&gt; <span class="keywordtype">void</span> initPages(<span class="keyword">const</span> TBounds&amp; bounds, <span class="keyword">const</span> Ogre::Any &amp;data = Ogre::Any(), Ogre::uint32 queryFlag = 0);
<a name="l01467"></a>01467 
<a name="l01469"></a>01469     <span class="keywordtype">void</span> update(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> deltaTime, Ogre::Vector3 &amp;camPos, Ogre::Vector3 &amp;camSpeed, <span class="keywordtype">bool</span> &amp;enableCache, GeometryPageManager *prevManager);
<a name="l01470"></a>01470 
<a name="l01472"></a>01472     <span class="keywordtype">void</span> reloadGeometry();
<a name="l01473"></a>01473 
<a name="l01475"></a>01475     <span class="keywordtype">void</span> reloadGeometryPage(<span class="keyword">const</span> Ogre::Vector3 &amp;point);
<a name="l01476"></a>01476 
<a name="l01478"></a>01478     <span class="keywordtype">void</span> reloadGeometryPages(<span class="keyword">const</span> Ogre::Vector3 &amp;center, Ogre::Real radius);
<a name="l01479"></a>01479 
<a name="l01481"></a>01481     <span class="keywordtype">void</span> reloadGeometryPages(<span class="keyword">const</span> TBounds &amp; area);
<a name="l01482"></a>01482 
<a name="l01484"></a>01484     <span class="keywordtype">void</span> preloadGeometry(<span class="keyword">const</span> TBounds &amp; area);
<a name="l01485"></a>01485 
<a name="l01487"></a>01487     <span class="keywordtype">void</span> resetPreloadedGeometry();
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 <span class="keyword">private</span>:
<a name="l01490"></a>01490     PagedGeometry *mainGeom;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     <span class="comment">//geomGrid is a 2D array storing all the GeometryPage instances managed by this object.</span>
<a name="l01493"></a>01493     GeometryPage **geomGrid;    <span class="comment">//A dynamic 2D array of pointers (2D grid of GeometryPage&#39;s)</span>
<a name="l01494"></a>01494     GeometryPage **scrollBuffer; <span class="comment">//A dynamic 1D array of pointers (temporary GeometryPage&#39;s used in scrolling geomGrid)</span>
<a name="l01495"></a>01495     <span class="keywordtype">int</span> geomGridX, geomGridZ;   <span class="comment">//The dimensions of the dynamic array</span>
<a name="l01496"></a>01496     TBounds      gridBounds;        <span class="comment">//Current grid bounds</span>
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     <span class="comment">//Fade transitions</span>
<a name="l01499"></a>01499     Ogre::Real fadeLength, fadeLengthSq;
<a name="l01500"></a>01500     <span class="keywordtype">bool</span> fadeEnabled;
<a name="l01501"></a>01501 
<a name="l01502"></a>01502     <span class="comment">//Inline function used to get geometry page tiles</span>
<a name="l01503"></a>01503     <span class="keyword">inline</span> GeometryPage *_getGridPage(<span class="keyword">const</span> <span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">int</span> z)
<a name="l01504"></a>01504     {
<a name="l01505"></a>01505 <span class="preprocessor">        #ifdef _DEBUG</span>
<a name="l01506"></a>01506 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(x &gt;= geomGridX || z &gt;= geomGridZ )
<a name="l01507"></a>01507             OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS,
<a name="l01508"></a>01508                 <span class="stringliteral">&quot;Grid dimension is out of bounds&quot;</span>,
<a name="l01509"></a>01509                 <span class="stringliteral">&quot;GeometryPageManager::_getGridPage()&quot;</span>);
<a name="l01510"></a>01510 <span class="preprocessor">        #endif</span>
<a name="l01511"></a>01511 <span class="preprocessor"></span>
<a name="l01512"></a>01512         <span class="keywordflow">return</span> geomGrid[z * geomGridX + x];
<a name="l01513"></a>01513     }
<a name="l01514"></a>01514     <span class="keyword">inline</span> <span class="keywordtype">void</span> _setGridPage(<span class="keyword">const</span> <span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">int</span> z, GeometryPage *page)
<a name="l01515"></a>01515     {
<a name="l01516"></a>01516 <span class="preprocessor">        #ifdef _DEBUG</span>
<a name="l01517"></a>01517 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(x &gt;= geomGridX || z &gt;= geomGridZ )
<a name="l01518"></a>01518             OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS,
<a name="l01519"></a>01519                 <span class="stringliteral">&quot;Grid dimension is out of bounds&quot;</span>,
<a name="l01520"></a>01520                 <span class="stringliteral">&quot;GeometryPageManager::_setGridPage()&quot;</span>);
<a name="l01521"></a>01521 <span class="preprocessor">        #endif</span>
<a name="l01522"></a>01522 <span class="preprocessor"></span>
<a name="l01523"></a>01523         geomGrid[z * geomGridX + x] = page;
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525 
<a name="l01526"></a>01526     <span class="comment">//Utility functions for loading/unloading geometry pages (see source for detailed descriptions)</span>
<a name="l01527"></a>01527     <span class="keywordtype">void</span> _loadPage(GeometryPage *page);
<a name="l01528"></a>01528     <span class="keywordtype">void</span> _unloadPage(GeometryPage *page);
<a name="l01529"></a>01529     <span class="keywordtype">void</span> _unloadPageDelayed(GeometryPage *page);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     <span class="comment">//Utility function for scrolling pages in the grid by the given amount</span>
<a name="l01532"></a>01532     <span class="keywordtype">void</span> _scrollGridPages(<span class="keywordtype">int</span> shiftX, <span class="keywordtype">int</span> shiftZ);
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 
<a name="l01535"></a>01535     <span class="comment">//Timer counting how long it has been since the last page has been cached</span>
<a name="l01536"></a>01536     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cacheTimer;
<a name="l01537"></a>01537 
<a name="l01538"></a>01538     TPGeometryPages pendingList;    <span class="comment">//Pages of geometry to be loaded</span>
<a name="l01539"></a>01539     TPGeometryPages loadedList; <span class="comment">//Pages of geometry already loaded</span>
<a name="l01540"></a>01540 
<a name="l01541"></a>01541     <span class="comment">//Cache settings</span>
<a name="l01542"></a>01542     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxCacheInterval;
<a name="l01543"></a>01543     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> inactivePageLife;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545     <span class="comment">//Near and far visibility ranges for this type of geometry</span>
<a name="l01546"></a>01546     Ogre::Real nearDist, nearDistSq;
<a name="l01547"></a>01547     Ogre::Real farDist, farDistSq;
<a name="l01548"></a>01548     Ogre::Real farTransDist, farTransDistSq;    <span class="comment">//farTransDist = farDist + fadeLength</span>
<a name="l01549"></a>01549 };
<a name="l01550"></a>01550 
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="comment">//-------------------------------------------------------------------------------------</span>
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 <span class="keyword">template</span> &lt;<span class="keyword">class</span> PageType&gt; <span class="keyword">inline</span> GeometryPageManager* PagedGeometry::addDetailLevel(Ogre::Real maxRange, Ogre::Real transitionLength, <span class="keyword">const</span> Ogre::Any &amp;data, Ogre::uint32 queryFlag)
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557     <span class="comment">//Create a new page manager</span>
<a name="l01558"></a>01558     GeometryPageManager *mgr = <span class="keyword">new</span> GeometryPageManager(<span class="keyword">this</span>);
<a name="l01559"></a>01559 
<a name="l01560"></a>01560     <span class="comment">//If vertex shaders aren&#39;t supported, don&#39;t use transitions</span>
<a name="l01561"></a>01561     Ogre::Root *root = root-&gt;getSingletonPtr(); <span class="comment">//Work-around for Linux compiler bug</span>
<a name="l01562"></a>01562     <span class="keywordflow">if</span> (!root-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;hasCapability(Ogre::RSC_VERTEX_PROGRAM))
<a name="l01563"></a>01563         transitionLength = 0;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565     <span class="comment">//Add it to the list (also initializing maximum viewing distance)</span>
<a name="l01566"></a>01566     _addDetailLevel(mgr, maxRange, transitionLength);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568     <span class="comment">//And initialize the paged (dependent on maximum viewing distance)</span>
<a name="l01569"></a>01569     mgr-&gt;initPages&lt;PageType&gt;(getBounds(), data, queryFlag);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571     <span class="keywordflow">return</span> mgr;
<a name="l01572"></a>01572 }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574 <span class="keyword">template</span> &lt;<span class="keyword">class</span> PageType&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> GeometryPageManager::initPages(<span class="keyword">const</span> TBounds&amp; bounds, <span class="keyword">const</span> Ogre::Any &amp;data, Ogre::uint32 queryFlag)
<a name="l01575"></a>01575 {
<a name="l01576"></a>01576     <span class="comment">// Calculate grid size, if left is Real minimum, it means that bounds are infinite</span>
<a name="l01577"></a>01577     <span class="comment">// scrollBuffer is used as a flag. If it is allocated than infinite bounds are used</span>
<a name="l01578"></a>01578     <span class="comment">// !!! Two cases are required because of the way scrolling is implemented</span>
<a name="l01579"></a>01579     <span class="comment">// if it is redesigned it would allow to use the same functionality.</span>
<a name="l01580"></a>01580     <span class="keywordflow">if</span>(bounds.width() &lt; 0.00001)
<a name="l01581"></a>01581     {
<a name="l01582"></a>01582         <span class="comment">// In case of infinite bounds bounding rect needs to be calculated in a different manner, since</span>
<a name="l01583"></a>01583         <span class="comment">// it represents local bounds, which are shifted along with the player&#39;s movements around the world.</span>
<a name="l01584"></a>01584         geomGridX = (2 * farTransDist / mainGeom-&gt;getPageSize()) + 4;
<a name="l01585"></a>01585         gridBounds.top = 0;
<a name="l01586"></a>01586         gridBounds.left = 0;
<a name="l01587"></a>01587         gridBounds.right = geomGridX * mainGeom-&gt;getPageSize();
<a name="l01588"></a>01588         gridBounds.bottom = geomGridX * mainGeom-&gt;getPageSize();
<a name="l01589"></a>01589         <span class="comment">// Allocate scroll buffer (used in scrolling the grid)</span>
<a name="l01590"></a>01590         scrollBuffer = <span class="keyword">new</span> GeometryPage *[geomGridX];
<a name="l01591"></a>01591 
<a name="l01592"></a>01592         <span class="comment">//Note: All this padding and transition preparation is performed because even in infinite</span>
<a name="l01593"></a>01593         <span class="comment">//mode, a local grid size must be chosen. Unfortunately, this also means that view ranges</span>
<a name="l01594"></a>01594         <span class="comment">//and transition lengths cannot be exceeded dynamically with set functions.</span>
<a name="l01595"></a>01595     }
<a name="l01596"></a>01596     <span class="keywordflow">else</span>
<a name="l01597"></a>01597     {
<a name="l01598"></a>01598         <span class="comment">//Bounded mode</span>
<a name="l01599"></a>01599         gridBounds = bounds;
<a name="l01600"></a>01600         <span class="comment">// In case the devision does not give the round number use the next largest integer</span>
<a name="l01601"></a>01601         geomGridX = std::ceil(gridBounds.width() / mainGeom-&gt;getPageSize());
<a name="l01602"></a>01602     }
<a name="l01603"></a>01603     geomGridZ = geomGridX; <span class="comment">//Note: geomGridX == geomGridZ; Need to merge.</span>
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     <span class="comment">//Allocate grid array</span>
<a name="l01607"></a>01607     geomGrid = <span class="keyword">new</span> GeometryPage *[geomGridX * geomGridZ];
<a name="l01608"></a>01608 
<a name="l01609"></a>01609     <span class="keywordtype">int</span> xioffset = Ogre::Math::Floor(gridBounds.left / mainGeom-&gt;getPageSize());
<a name="l01610"></a>01610     <span class="keywordtype">int</span> zioffset = Ogre::Math::Floor(gridBounds.top / mainGeom-&gt;getPageSize());
<a name="l01611"></a>01611     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; geomGridX; ++x)
<a name="l01612"></a>01612     {
<a name="l01613"></a>01613         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = 0; z &lt; geomGridZ; ++z)
<a name="l01614"></a>01614         {
<a name="l01615"></a>01615             GeometryPage* page = <span class="keyword">new</span> PageType();
<a name="l01616"></a>01616             page-&gt;init(mainGeom, data);
<a name="l01617"></a>01617             <span class="comment">// 0,0 page is located at (gridBounds.left,gridBounds.top) corner of the bounds</span>
<a name="l01618"></a>01618             page-&gt;_centerPoint.x = ((x + 0.5f) * mainGeom-&gt;getPageSize()) + gridBounds.left;
<a name="l01619"></a>01619             page-&gt;_centerPoint.z = ((z + 0.5f) * mainGeom-&gt;getPageSize()) + gridBounds.top;
<a name="l01620"></a>01620             page-&gt;_centerPoint.y = 0.0f;
<a name="l01621"></a>01621             page-&gt;_xIndex = x + xioffset;
<a name="l01622"></a>01622             page-&gt;_zIndex = z + zioffset;
<a name="l01623"></a>01623             page-&gt;_inactiveTime = 0;
<a name="l01624"></a>01624             page-&gt;_loaded = <span class="keyword">false</span>;
<a name="l01625"></a>01625             page-&gt;_needsUnload = <span class="keyword">false</span>;
<a name="l01626"></a>01626             page-&gt;_pending = <span class="keyword">false</span>;
<a name="l01627"></a>01627             page-&gt;_keepLoaded = <span class="keyword">false</span>;
<a name="l01628"></a>01628             page-&gt;_visible = <span class="keyword">false</span>;
<a name="l01629"></a>01629             page-&gt;_userData = 0;
<a name="l01630"></a>01630             page-&gt;_fadeEnable = <span class="keyword">false</span>;
<a name="l01631"></a>01631             page-&gt;setQueryFlag(queryFlag);
<a name="l01632"></a>01632 
<a name="l01633"></a>01633             page-&gt;clearBoundingBox();
<a name="l01634"></a>01634 
<a name="l01635"></a>01635             _setGridPage(x, z, page);
<a name="l01636"></a>01636         }
<a name="l01637"></a>01637     }
<a name="l01638"></a>01638 }
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 
<a name="l01641"></a>01641 }
<a name="l01642"></a>01642 
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 19 2013 09:55:43 for PagedGeometry by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
